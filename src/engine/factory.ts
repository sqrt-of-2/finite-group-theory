// src/engine/factory.ts
import { ConcreteGroup } from './ConcreteGroup';
import { Permutation } from './permutation';
import type { IGroup } from './types';

// ... (previous imports)



// Z_n implementation using numbers
export function createCn(n: number): ConcreteGroup<number> {
    return new ConcreteGroup<number>(
        `Z_${n}`, `Z_${n}`,
        [1], // Generator 1
        (a, b) => (a + b) % n,
        (a) => (n - a) % n,
        0,
        (a) => String(a),
        (a) => String(a)
    );
}

// S_n implementation
export function createSn(n: number): ConcreteGroup<Permutation> {
    const transposition = Permutation.fromCycles(n, [[1, 2]]);
    const cycle = Permutation.fromCycles(n, [Array.from({ length: n }, (_, i) => i + 1)]);

    return new ConcreteGroup<Permutation>(
        `S_${n}`, `S_${n}`,
        [transposition, cycle],
        (a, b) => a.multiply(b),
        (a) => a.inverse(),
        Permutation.identity(n),
        (p) => p.toString(),
        (p) => p.format()
    );
}

// D_n (or D_2n). Input n is the size of polygon (so order 2n).
export function createDn(n: number): ConcreteGroup<Permutation> {
    const r = Permutation.fromCycles(n, [Array.from({ length: n }, (_, i) => i + 1)]);
    // Reflection s: (1)(2 n)(3 n-1)...
    const map = new Array(n);
    map[0] = 0; // 0-based
    for (let i = 1; i < n; i++) {
        map[i] = n - i;
    }
    const s = new Permutation(map);

    return new ConcreteGroup<Permutation>(
        `D_${2 * n}`, `D_{${2 * n}}`,
        [r, s],
        (a, b) => a.multiply(b),
        (a) => a.inverse(),
        Permutation.identity(n),
        (p) => p.toString(),
        (p) => p.format()
    );
}

// A_n
export function createAn(n: number): ConcreteGroup<Permutation> {
    // Generators for A_n:
    // for n=3: (1 2 3)
    // for n>=3: A_n generated by 3-cycles (1 2 3), (1 2 4), ... 
    // Actually generated by (1 2 3) and (1 2 ... n) if n is odd, etc?
    // Simpler: Generate S_n, then filter even ones? 
    // But factory expects generators.
    // Known generators for A_n:
    // (1 2 3) and (1 2 ... n) is NOT always An.
    // Generator set: (1 2 3), (1 2 4), ..., (1 2 n).
    if (n < 3) throw new Error("A_n requires n>=3");

    const generators: Permutation[] = [];
    // (1 2 3), (1 2 4), ... (1 2 n) generate An?
    // Actually (1 2 i) for i=3..n
    for (let k = 3; k <= n; k++) {
        generators.push(Permutation.fromCycles(n, [[1, 2, k]]));
    }

    return new ConcreteGroup<Permutation>(
        `A_${n}`, `A_${n}`,
        generators,
        (a, b) => a.multiply(b),
        (a) => a.inverse(),
        Permutation.identity(n),
        (p) => p.toString(),
        (p) => p.format()
    );
}

// Q_8: Quaternion group {1, -1, i, -i, j, -j, k, -k}
// Matrix representation or manual table.
// Pauli matrices map.
// 1 -> I, -1 -> -I, i -> iSx, j -> iSy, k -> iSz
// Or:
// elements: 1, i, j, k, -1, -i, -j, -k
// Multiply rule: i*i=-1, j*j=-1, k*k=-1, i*j=k, j*i=-k
// Let's use string "1", "i", "j", "k", "-1", "-i", "-j", "-k" and manual table?
// Or 2x2 complex matrices.
// Or Permutation representation of Q8 (subgroup of S8).
// Q8 acts on {1, i, j, k, -1, -i, -j, -k} by left multiplication (Regular representation).
// Cayley's theorem says every group is subgroup of Sn. |G|=8 -> S8.
// Let's use specific permutation representation for Q8 in S8.
// Elements: e, i, j, k, e', i', j', k' (primes are negatives)
// i maps: 1->i, i->-1, j->k, k->-j, -1->-i, -i->1, -j->-k, -k->j
// map indices: 1->2, 2->5, 3->4, 4->8, 5->6, 6->1, 7->9...
// Let's implement manually with strict Logic logic or just hardcode permutations.
// Permutations:
// i: (1 2 3 4)(5 6 7 8) ? No order 4.
// Let 1=1, -1=2, i=3, -i=4, j=5, -j=6, k=7, -k=8
// i * 1 = i (3)
// i * -1 = -i (4)
// i * i = -1 (2)
// i * -i = 1 (1)
// Cycle: (1 3 2 4). i.e. 1->3->2->4->1.
// i * j = k (7)
// i * -j = -k (8)
// i * k = -j (6)
// i * -k = j (5)
// Cycle: (5 7 6 8).
// So i ~= (1 3 2 4)(5 7 6 8).
// j: (1 5 2 6)(3 8 4 7)
// Check i*j:
// 1 -> i(3) -> j(8? no j(3)=8) -> 8(-k).  1->8 (k? No 1*i*j = k=7).
// Wait, we generate group from generators i, j.
// i = (1 3 2 4)(5 7 6 8)
// j = (1 5 2 6)(3 8 4 7)
export function createQ8(): ConcreteGroup<Permutation> {
    const i = Permutation.fromCycles(8, [[1, 3, 2, 4], [5, 7, 6, 8]]);
    const j = Permutation.fromCycles(8, [[1, 5, 2, 6], [3, 8, 4, 7]]);

    // Custom label map
    const labelMap: Record<string, string> = {
        [Permutation.identity(8).toString()]: "1",
        [i.multiply(i).toString()]: "-1",
        [i.toString()]: "i",
        [i.multiply(i).multiply(i).toString()]: "-i", // i^3
        [j.toString()]: "j",
        [j.multiply(j).multiply(j).toString()]: "-j",
        [i.multiply(j).toString()]: "k",
        [j.multiply(i).toString()]: ("-k") // or k^-1
    };

    // We should compute closure logic.
    // The group logic will compute elements.

    return new ConcreteGroup<Permutation>(
        'Q_8', 'Q_8',
        [i, j],
        (a, b) => a.multiply(b),
        (a) => a.inverse(),
        Permutation.identity(8),
        (p) => p.toString(),
        (p) => labelMap[p.toString()] || p.format() // Fallback to format if not mapped (should not happen)
    );
}

// Klein 4 group V4 ~ Z2 x Z2
// Klein 4 group V4 ~ Z2 x Z2
export function createKlein4(): ConcreteGroup<Permutation> {
    const a = Permutation.fromCycles(4, [[1, 2], [3, 4]]);
    const b = Permutation.fromCycles(4, [[1, 3], [2, 4]]);
    return new ConcreteGroup<Permutation>(
        'Z_2_x_Z_2', 'Z_2 \\times Z_2',
        [a, b],
        (x, y) => x.multiply(y),
        (x) => x.inverse(),
        Permutation.identity(4)
    );
}

// Direct Product G x H
export function createDirectProduct(G: IGroup, H: IGroup): ConcreteGroup<string> {
    // Elements are "G_id:H_id"
    const newId = `${G.displayName} \\times ${H.displayName}`;
    const rawId = `${G.id}_x_${H.id}`;

    // We pre-compute elements to set up the group
    // But ConcreteGroup takes generators. 
    // Generators of GxH = (g, 1) for g in Gen(G) u (1, h) for h in Gen(H).
    // Wait, ConcreteGroup takes `generators` as T[].
    // T in this case is string "id_g:id_h".

    // To use ConcreteGroup with string type, we need multiply/invert functions that parse the string.

    // A better approach: 
    // Just generate all elements and pass them as generators? Using Closure will verify.
    // Or better: Pass (g, 1) and (1, h) where g, h are generators.

    // We need access to generators of G and H. 
    // IGroup doesn't expose generators publicly in interface. 
    // We can iterate all elements as generators (naive but works).

    // Actually, we can just define the multiply/invert function and pass all elements as "generators" (or just the identity if we want to build it manually? no generic closure needs generators).

    // Let's use pairs [gId, hId] joined by a separator.
    const sep = "|";
    const encode = (g: string, h: string) => `${g}${sep}${h}`;
    const decode = (x: string) => x.split(sep);

    const gIdent = G.getIdentity();
    const hIdent = H.getIdentity();
    const identity = encode(gIdent, hIdent);

    // Generators: 
    // We don't have G.generators access. 
    // Let's use all elements of G paired with hIdent, and gIdent paired with all elements of H.
    // This guarantees generation.
    // Optimization: If G, H are small, |G|+|H| generators is fine.

    const generators: string[] = [];
    G.elements.forEach(g => {
        if (g.id !== gIdent) generators.push(encode(g.id, hIdent));
    });
    H.elements.forEach(h => {
        if (h.id !== hIdent) generators.push(encode(gIdent, h.id));
    });

    if (generators.length === 0) generators.push(identity); // Trivial group check

    return new ConcreteGroup<string>(
        rawId, newId,
        generators,
        (a, b) => {
            const [g1, h1] = decode(a);
            const [g2, h2] = decode(b);
            return encode(G.multiply(g1, g2), H.multiply(h1, h2));
        },
        (a) => {
            const [g, h] = decode(a);
            return encode(G.invert(g), H.invert(h));
        },
        identity,
        (a) => a, // identify
        (a) => {
            const [g, h] = decode(a);
            // Smart label: if g is e, show h. if h is e, show g.
            // Actually (g, h) tuple notation is clearer usually.
            const gLabel = G.elements.find(x => x.id === g)?.label || g;
            const hLabel = H.elements.find(x => x.id === h)?.label || h;

            // If KaTex, maybe use (g, h)
            return `(${gLabel}, ${hLabel})`;
        }
    );
}


// Dicyclic Group Dic_n (Order 4n)
// Dic_2 = Q8. Dic_3 (Order 12).
// Generators: a (order 2n), x (order 4, x^2 = a^n)
// Relation: x^{-1} a x = a^{-1}
// Permutation representation for Dic_n (from literature or constructed):
// Let a = (1 2 ... 2n)(2n+1 ... 4n) ?
// Let's try regular representation or similar.
// Dic_n has 4n elements.
// Generators a, x.
// a = (1 2 ... 2n) is order 2n.
// x needs to map 1->?, ...
// Maybe simpler: Q_12 is Z_3 \rtimes Z_4 ? No.
// Let's use the known permutation representation for Dic_3 (Order 12).
// Reference: Generators for Dic3 <= S12?
// a = (1 2 3 4 5 6)(7 8 9 10 11 12)
// x = (1 8 4 11)(2 7 5 10)(3 12 6 9)  <-- Check relations
// order(a) = 6. a^3 = (1 4)(2 5)(3 6)(7 10)(8 11)(9 12)
// order(x) = 4. x^2 = (1 4)(8 11)(2 5)(7 10)(3 6)(12 9) = a^3. Matches!
// x^-1 a x = ?
// x^-1 = (1 11 4 8)...
// Conjugate a by x:
// 1 -> x(8) -> a(9) -> xinv(12).  (1->12) implies a^-1?
// a^-1 = (1 6 5 4 3 2)...
// 1 in a^-1 maps to 6.
// Wait, 1->12 is not 1->6.
// Maybe mapping is different.
// Try x = (1 7 4 10)(2 12 5 9)(3 11 6 8)?
// Check x^2 = (1 4)(7 10)(2 5)(12 9)(3 6)(11 8) = a^3? 
// a^3 = (1 4)(2 5)(3 6)(7 10)(8 11)(9 12).
// (2 5), (3 6) match. (1 4), (7 10) match.
// x^2 has (12 9) -> 9->12 map. a^3 has (9 12). Matches.
// x^2 has (11 8) -> 8->11. a^3 has (8 11). Matches.
// So x^2 = a^3 holds.
// Check x^-1 a x = a^-1.
// x = (1 7 4 10)...
// x: 1->7, 7->4, 4->10, 10->1
// x^-1: 1->10, 10->4, 4->7, 7->1
// a: 1->2...
// x^-1 a x (1) = x(1)=7 -> a(7)=8 -> x^-1(8)=?
// x has (3 11 6 8) from previous attempt? No, current x is (1 7 4 10)(2 12 5 9)(3 11 6 8)
// let's verify cycle structure of x. 1, 4, 7, 10 used. 2, 5, 9, 12 used. 3, 6, 8, 11 used. All 12.
// x(1)=7, a(7)=8, xinv(8)=3 because x(3)=11, x(6)=8 -> xinv(8)=6.
// So 1 -> 6.
// a^-1 (1) = 6. Matches!
// x^-1 a x (2). x(2)=12, a(12)=7, xinv(7)=1.
// a^-1(2) = 1. Matches!
// Seems correct.
export function createDic3(): ConcreteGroup<Permutation> {
    const a = Permutation.fromCycles(12, [
        [1, 2, 3, 4, 5, 6],
        [7, 8, 9, 10, 11, 12]
    ]);
    const x = Permutation.fromCycles(12, [
        [1, 7, 4, 10],
        [2, 12, 5, 9],
        [3, 11, 6, 8]
    ]);

    return new ConcreteGroup<Permutation>(
        'Dic_3', 'Dic_3',
        [a, x],
        (m, n) => m.multiply(n),
        (m) => m.inverse(),
        Permutation.identity(12),
        (p) => p.toString(),
        (p) => p.format()
    );
}

