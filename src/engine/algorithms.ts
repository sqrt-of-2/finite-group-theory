
// src/engine/algorithms.ts
import type { CayleyTable } from './types';

// Generic closure algorithm
// Given generators and a multiply function, return all unique elements.
export function generateClosure<T>(
    generators: T[],
    multiply: (a: T, b: T) => T,
    identify: (a: T) => string, // To dedup elements
    identity: T
): { elements: T[], map: Record<string, T> } {
    const map: Record<string, T> = {};
    const elements: T[] = [];

    // Add identity first
    const idKey = identify(identity);
    map[idKey] = identity;
    elements.push(identity);

    // const queue: T[] = [...generators];
    // If generators don't include identity, effectively they will be processed.
    // Actually we should start with identity in the closed set, and try multiplying everything by generators?
    // BFS approach:
    // Queue initial contains generators.
    // actually, queue should be "elements to process".
    // We already have identity.

    // Better BFS:
    // known = {id}
    // queue = [id]
    // loop queue:
    //   u = pop
    //   for g in generators:
    //      v = u * g
    //      if v not in known:
    //         add v to known, queue
    // This only generates <generators>.
    // If we want to generate including 'identity' even if generators is empty (should return {e}), this works.

    // Re-initialize for robustness
    // If generators are empty, return {id}
    if (generators.length === 0) {
        return { elements: [identity], map: { [idKey]: identity } };
    }

    // Reset
    const resultElements = [identity];
    const resultMap: Record<string, T> = { [idKey]: identity };


    // Also need to handle if generators are not in 'resultElements' initially? 
    // The BFS above generates <Generators>, so if identity is not generated by Generators (impossible for finite groups except empty set which handled), we are good.
    // Wait, typical BFS for closure:
    // Start with {e}.
    // Repeatedly multiply existing set by generators until stable.

    // Optimization: New elements = Elements * Generators.

    // Start loop
    let head = 0;
    while (head < resultElements.length) {
        const current = resultElements[head];
        head++;

        for (const gen of generators) {
            const product = multiply(current, gen);
            const key = identify(product);
            if (resultMap[key] === undefined) {
                resultMap[key] = product;
                resultElements.push(product);
            }
        }
    }

    return { elements: resultElements, map: resultMap };
}

// Generate Cayley Table from a closed set of elements
export function generateCayleyTable<T>(
    elements: T[],
    multiply: (a: T, b: T) => T,
    identify: (a: T) => string
): CayleyTable {
    const ids = elements.map(identify);
    const table: Record<string, Record<string, string>> = {};

    for (let i = 0; i < elements.length; i++) {
        const rowId = ids[i];
        table[rowId] = {};
        for (let j = 0; j < elements.length; j++) {
            const colId = ids[j];
            const product = multiply(elements[i], elements[j]);
            table[rowId][colId] = identify(product);
        }
    }

    return { elements: ids, table };
}

// Basic Conjugacy Classes
export function findConjugacyClasses(
    elements: string[],
    table: Record<string, Record<string, string>>,
    inverseMap: Record<string, string>
): string[][] {
    const visited = new Set<string>();
    const classes: string[][] = [];

    for (const x of elements) {
        if (visited.has(x)) continue;

        const cls = new Set<string>();
        cls.add(x);

        // Conjugate by every g: g x g^-1
        for (const g of elements) {
            const gInv = inverseMap[g];
            // g * x
            const gx = table[g][x];
            // (g * x) * g^-1
            const gxgInv = table[gx][gInv];
            cls.add(gxgInv);
        }

        const clsArray = Array.from(cls);
        clsArray.forEach(c => visited.add(c));
        classes.push(clsArray);
    }
    return classes;
}

// Subgroups - simple cyclic + closure method
// This is not exhaustive for all groups but good start.
// Better: Dimino's Algorithm or simplified:
// 1. Start with L = [{e}]
// 2. Iterate through elements g in G.
// 3. For each S in L, generate closure <S, g>.
// 4. Add new subgroups to L.
// Note: This is $O(N \cdot |Subgroups| \cdot |G|)$. For N=60, this might be heavy but ok in JS.
export function findAllSubgroups(
    elements: string[],
    table: Record<string, Record<string, string>>,
    identity: string
): string[][] { // Returns lists of element IDs
    const subgroups: Set<string> = new Set(); // Store as sorted joined strings to dedup
    const result: string[][] = [];

    // Helper to canonically stringify a subgroup
    const canonical = (els: string[]) => els.sort().join(',');

    // Initial subgroup: {e}
    const trivial = [identity];
    subgroups.add(canonical(trivial));
    result.push(trivial);

    // We iterate existing subgroups and try extending them with an element outside.
    // To avoid over-work, we can just iterate `result` (which grows) and `elements`.
    // But modifying `result` while iterating is tricky.

    // Algorithm refinement: 
    // Level-based? No.
    // Just simple iteration:
    // found = [{e}]
    // for x in elements:
    //    new_found = []
    //    for S in found:
    //       if x in S: continue
    //       S' = <S, x> (closure)
    //       if S' is new: new_found.add(S')
    //    found.push(...new_found)

    // Closure of a set of IDs using the table
    const getClosure = (s: string[]): string[] => {
        // BFS closure
        const current = new Set(s);
        const q = [...s];
        let head = 0;
        while (head < q.length) {
            const u = q[head++];
            for (const v of q) { // Multiply by all existing elements (all pairs)
                // This ensures closure.
                // Actually standard closure is: while something added: for all x,y in set, add x*y.
                const prod = table[u][v];
                if (!current.has(prod)) {
                    current.add(prod);
                    q.push(prod);
                }
                // Also v*u?
                const prod2 = table[v][u];
                if (!current.has(prod2)) {
                    current.add(prod2);
                    q.push(prod2);
                }
            }
        }
        return Array.from(current);
    };

    // Optimization: Only try extending with elements NOT in the subgroup.
    // Also we don't need to try extending with ALL x. Just cyclic subgroups first?
    // Let's stick to the "extend existing subgroups" approach.

    for (const x of elements) {
        // Create a snapshot of current subgroups to iterate
        const currentSubgroups = [...result];

        for (const sub of currentSubgroups) {
            const subSet = new Set(sub);
            if (subSet.has(x)) continue;

            // Generate <sub, x>
            // We can optimize by seeding the closure with `sub` + `x`
            const newSub = getClosure([...sub, x]);
            const key = canonical(newSub);

            if (!subgroups.has(key)) {
                subgroups.add(key);
                result.push(newSub);
            }
        }
    }

    return result;
}

export function isAbelian(
    elements: string[],
    table: Record<string, Record<string, string>>
): boolean {
    for (const a of elements) {
        for (const b of elements) {
            if (table[a][b] !== table[b][a]) return false;
        }
    }
    return true;
}

export function findCenter(
    elements: string[],
    table: Record<string, Record<string, string>>
): string[] {
    const center: string[] = [];
    for (const a of elements) {
        let commutesWithAll = true;
        for (const b of elements) {
            if (table[a][b] !== table[b][a]) {
                commutesWithAll = false;
                break;
            }
        }
        if (commutesWithAll) center.push(a);
    }
    return center;
}
