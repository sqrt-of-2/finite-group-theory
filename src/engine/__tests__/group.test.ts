
import { describe, it, expect } from 'vitest';
import { Permutation } from '../permutation';
import { ConcreteGroup } from '../ConcreteGroup';

describe('Permutation', () => {
    it('should compute identity', () => {
        const id = Permutation.identity(3);
        expect(id.toString()).toBe('0,1,2');
        expect(id.format()).toBe('(1)');
    });

    it('should multiply correctly (cycles)', () => {
        // (1 2) * (1 3) = (1 3 2) ? Or (1 2 3)?
        // Dummit & Foote (right to left): (1 2) * (1 3) means apply (1 3) then (1 2).
        // x=1 -> (1 3)->3 -> (1 2)->3. So 1->3
        // x=3 -> (1 3)->1 -> (1 2)->2. So 3->2
        // x=2 -> (1 3)->2 -> (1 2)->1. So 2->1
        // (1 3 2)

        const p1 = Permutation.fromCycles(3, [[1, 2]]);
        const p2 = Permutation.fromCycles(3, [[1, 3]]);

        const prod = p1.multiply(p2);
        // (1 3 2) means 1->3, 3->2, 2->1.
        expect(prod.format()).toBe('(1 3 2)');
    });

    it('should inverse', () => {
        const p = Permutation.fromCycles(3, [[1, 2, 3]]); // (1 2 3)
        const inv = p.inverse();
        expect(inv.format()).toBe('(1 3 2)');

        const prod = p.multiply(inv);
        expect(prod.format()).toBe('(1)');
    });
});

describe('S3 Group Logic', () => {
    // S3 generated by (1 2) and (1 2 3)
    const s1 = Permutation.fromCycles(3, [[1, 2]]);
    const s2 = Permutation.fromCycles(3, [[1, 2, 3]]);

    const S3 = new ConcreteGroup<Permutation>(
        'S3', 'S_3',
        [s1, s2],
        (a, b) => a.multiply(b),
        (a) => a.inverse(),
        Permutation.identity(3),
        (p) => p.toString(),
        (p) => p.format()
    );

    it('should have order 6', () => {
        const props = S3.getProperties();
        expect(props.order).toBe(6);
    });

    it('should not be abelian', () => {
        const props = S3.getProperties();
        expect(props.isAbelian).toBe(false);
    });

    it('should have correct subgroups', () => {
        // Total subgroups of S3: 6
        // Order 1: {e}
        // Order 2: <(1 2)>, <(1 3)>, <(2 3)> (3)
        // Order 3: <(1 2 3)> (1)
        // Order 6: S3 (1)

        const subgroups = S3.getSubgroups();
        expect(subgroups.length).toBe(6);

        const orders = subgroups.map(s => s.order).sort((a, b) => a - b);
        expect(orders).toEqual([1, 2, 2, 2, 3, 6]);
    });

    it('should identify normal subgroups', () => {
        const subgroups = S3.getSubgroups();
        const normals = subgroups.filter(s => s.isNormal);
        // Normals: {e}, A3(=<(1 2 3)>), S3. Total 3.
        expect(normals.length).toBe(3);
        const normalOrders = normals.map(s => s.order).sort((a, b) => a - b);
        expect(normalOrders).toEqual([1, 3, 6]);
    });

    it('should have trivial center', () => {
        const props = S3.getProperties();
        expect(props.center?.length).toBe(1);
    });
});
